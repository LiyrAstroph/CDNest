/*
 * C version of Diffusive Nested Sampling (DNest4) by Brendon J. Brewer
 *
 * Yan-Rong Li, liyanrong@mail.ihep.ac.cn
 * Jun 30, 2016
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include <gsl/gsl_rng.h>

#include "dnestvars.h"
#include "dnestproto.h"

/* post process the sample generated by dnest */ 
int cmp_sample(const void *pa, const void *pb);
typedef struct
{
  double logl, tiebreaker;
  int id;
}SampleType;

double logdiffexp(double x1, double x2)  // x1 is larger
{
  double biggest = x1;
  double xx1 = x1 - biggest, xx2 = x2 - biggest;
  return log(exp(xx1) - exp(xx2)) + biggest;
}

double logsumexp(double *x, int n)
{
  int j;
  double sum, max;
  
  max = x[0];
  for(j = 0; j < n; j++)
  {
    max = fmax(max, x[j]);
  }
  sum = 0.0;
  for(j=0; j< n; j++)
  {
    sum += exp( x[j] - max);
  }
  return log(sum) + max;
}

void postprocess()
{
  FILE *fp;
  
  double **levels_orig, **sample_info;
  int *sandwhich;
  ModelType *sample;
  int i, j;
  int num_levels, num_samples;
  char buf[BUF_MAX_LENGTH];
  int moreSample = 1;
  
  // read number of levels and samples
  fp = fopen(options.sampler_state_file, "r");
  if(fp == NULL)
  {
    fprintf(stderr, "# Error: Cannot open file %s.\n", options.sampler_state_file);
    exit(0);
  }
  fscanf(fp, "%d %d\n", &num_levels, &num_samples);
  fclose(fp);
  
  // allocate memory for levels
  levels_orig = malloc(num_levels * sizeof(double *));
  for(i=0; i< num_levels; i++)
  {
    levels_orig[i] = malloc(3 * sizeof(double));
  }
  
  // allocate memory for sample_info
  sample_info = malloc(num_samples * sizeof(double *));
  for(i=0; i< num_samples; i++)
  {
    sample_info[i] = malloc(3 * sizeof(double));
  }
  
  // allocate memory for samples
  sample = (ModelType *)malloc(num_samples * sizeof(ModelType));
  sandwhich = malloc(num_samples * sizeof(int));
  
  // read levels
  fp = fopen(options.levels_file, "r");
  fgets(buf, BUF_MAX_LENGTH, fp);
  for(i=0; i < num_levels; i++)
  {
    fgets(buf, BUF_MAX_LENGTH, fp);
    
    if(sscanf(buf, "%lf %lf %lf", &levels_orig[i][0], &levels_orig[i][1], &levels_orig[i][2]) < 3)
    {
      fprintf(stderr, "# Error: Cannot read file %s.\n", options.levels_file);
      exit(0);
    }
  }
  fclose(fp);
  
  // read sample_info
  fp = fopen(options.sample_info_file, "r");
  fgets(buf, BUF_MAX_LENGTH, fp);
  for(i=0; i < num_samples; i++)
  {
    fgets(buf, BUF_MAX_LENGTH, fp);
    if(sscanf(buf, "%lf %lf %lf", &sample_info[i][0], &sample_info[i][1], &sample_info[i][2]) < 3)
    {
      fprintf(stderr, "# Error: Cannot read file %s.\n", options.sample_info_file);
      exit(0);
    }
  }
  fclose(fp);
  
  // read sample
  fp = fopen(options.sample_file, "r");
  fgets(buf, BUF_MAX_LENGTH, fp);
  for(i=0; i < num_samples; i++)
  {
    for(j=0; j < num_params; j++)
    {
      if(!fscanf(fp, "%lf", &sample[i].params[j]))
      {
        fprintf(stderr, "# Error: Cannot read file %s.\n", options.sample_file);
        exit(0);
      }
    }
    //printf("%f %f %f\n", sample[i].params[0], sample[i].params[1], sample[i].params[2]);
  }
  fclose(fp);
  
  // finding sandwhiching levels for each samples
  for(i=0; i<num_samples; i++)
  {
    sandwhich[i] = (int)sample_info[i][0];
    
    for(j=sandwhich[i]; j < num_levels; j++)
    {
      if( sample_info[i][1] > levels_orig[j][1] )
        sandwhich[i] = j;
    }
    //printf("%f %d\n", sample_info[i][1], sandwhich[i]);
  }
  
  double *logx_samples, *logp_samples, *logP_samples;
  double logx_min, logx_max, Umin, U;
  int num_samples_thisLevel;
  double *logx_samples_thisLevel;
  SampleType *logl_samples_thisLevel;
  
  double left, right;
  
  logx_samples = malloc(num_samples * sizeof(double));
  logp_samples = malloc(num_samples * sizeof(double));
  logP_samples = malloc(num_samples * sizeof(double));
  
  logx_samples_thisLevel = malloc(num_samples * sizeof(double));
  logl_samples_thisLevel = malloc(num_samples * sizeof(SampleType));
  
  for(i=0; i<num_levels; i++)
  {
    logx_max = levels_orig[i][0];
    if(i == num_levels - 1)
      logx_min = -1.0E300;
    else
      logx_min = levels_orig[i+1][0];
    
    Umin = exp( logx_min - logx_max);
    
    // finding the samples sandwhiched by this levels
    num_samples_thisLevel = 0;
    for(j=0; j<num_samples; j++)
      if( sandwhich[j] == i )
      {
        logl_samples_thisLevel[num_samples_thisLevel].logl = sample_info[j][1]; // logl
        logl_samples_thisLevel[num_samples_thisLevel].tiebreaker = sample_info[j][2]; // tiebreaker
        logl_samples_thisLevel[num_samples_thisLevel].id = j; // id
        
        num_samples_thisLevel++;
      }
    
    //printf("%d\n", num_samples_thisLevel);
    
    for(j=0; j<num_samples_thisLevel; j++)
    {
      U = Umin + (1.0 - Umin) * ( 1.0/(1.0 + num_samples_thisLevel) 
           + ( 1.0 - 2.0/(1.0 + num_samples_thisLevel) ) * (num_samples_thisLevel-1 - j)/(num_samples_thisLevel - 1.0) );
      logx_samples_thisLevel[j] = logx_max + log(U);
    }
    
    qsort(logl_samples_thisLevel, num_samples_thisLevel, sizeof(SampleType), cmp_sample);
    
    //printf("%f %f %d %f\n", logl_samples_thisLevel[0].logl, logl_samples_thisLevel[0].tiebreaker, logl_samples_thisLevel[0].id, logx_samples_thisLevel[0]);
    //printf("%f %f %d %f\n", logl_samples_thisLevel[1].logl, logl_samples_thisLevel[1].tiebreaker, logl_samples_thisLevel[1].id, logx_samples_thisLevel[1]);
    
    
    for(j = 0; j<num_samples_thisLevel; j++)
    {
      if(j != num_samples_thisLevel - 1)
        left = logx_samples_thisLevel[j+1];
      else if (i == num_levels - 1)
        left = -1.0E300;
      else
        left = levels_orig[i+1][0];
        
      if( j!= 0)
        right = logx_samples_thisLevel[j-1];
      else
        right = levels_orig[i][0];
      
      //printf("%e %e %e\n", right, left, logdiffexp(right, left));
      
      logx_samples[logl_samples_thisLevel[j].id] = logx_samples_thisLevel[j];
      logp_samples[logl_samples_thisLevel[j].id] = log(0.5)  + logdiffexp(right, left);
    }
  }
  
  double sum, max, logz_estimates, H_estimates, ESS;
  
  
  sum = logsumexp(logp_samples, num_samples);
  for(j = 0; j < num_samples; j++)
  {
    logp_samples[j] -= sum;
    logP_samples[j] = logp_samples[j] + sample_info[j][1];
  }
  
  logz_estimates = logsumexp(logP_samples, num_samples);
  
  H_estimates = -logz_estimates;
  ESS = 0.0;
  for(j=0; j<num_samples; j++)
  {
    logP_samples[j] -= logz_estimates; 
    H_estimates += exp(logP_samples[j]) * sample_info[j][1];
    ESS += -logP_samples[j]*exp(logP_samples[j]);
  }
  ESS = exp(ESS);
    
  printf("log(Z) = %f\n", logz_estimates);
  printf("H = %f\n", H_estimates);
  printf("Effective sample size = %f\n", ESS);
  
  // resample to uniform weight
  
  int num_ps = moreSample*ESS;
  ModelType *posterior_sample;
  int which;
  
  posterior_sample = malloc(num_ps * sizeof(ModelType));
  
  max = logP_samples[0];
  for(j=0; j<num_samples; j++)
    max = fmax(logP_samples[j], max);
  for(j=0; j<num_samples; j++)
    logP_samples[j] -= max;
  
  for(j=0; j<num_ps; j++)
  {
    while(true)
    {
      which = dnest_rand_int(num_samples);
      if(log(dnest_rand()) < logP_samples[which])
      {
        memcpy(&posterior_sample[j], &sample[which], sizeof(ModelType));
        break;
      }
    }
  }
  
  //save posterior sample
  fp = fopen("posterior_sample.txt", "w");
  for(i=0; i<num_ps; i++)
  {
    for(j=0; j<num_params; j++)
      fprintf(fp, "%f ", posterior_sample[i].params[j]);
    fprintf(fp, "\n");
  }
  fclose(fp);
  
  ModelType best_model, best_model_std;
  for(j=0; j<num_params; j++)
  {
    best_model.params[j] = 0.0;
    for(i=0; i<num_ps; i++)
      best_model.params[j] += posterior_sample[i].params[j];
    best_model.params[j] /= num_ps;
    
    best_model_std.params[j] = 0.0;
    for(i=0; i<num_ps; i++)
      best_model_std.params[j] += pow( posterior_sample[i].params[j] - best_model.params[j], 2.0 );
    best_model_std.params[j] = sqrt(best_model_std.params[j]/(num_ps - 1.0));
    printf("Best params %d %f +- %f\n", j, best_model.params[j], best_model_std.params[j]);
  }
  
  
  for(i=0; i<num_levels; i++)
   free(levels_orig[i]);
  free(levels_orig);
}

int cmp_sample(const void *pa, const void *pb)
{
  SampleType *a = (SampleType *)pa;
  SampleType *b = (SampleType *)pb;

  // in acesending order
  if(a->logl > b->logl)
    return true;
  if( a->logl == b->logl && a->tiebreaker > b->tiebreaker)
    return true;
  
  return false;
}
